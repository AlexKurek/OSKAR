File: src/cuda/readme
===============================================================================

Description:
===============================================================================
This folder contains source code for the library module: oskar_cuda
This library provides math routines written in CUDA for execution on the GPU.


Library dependencies:
    cuda
    cudart
    cublas



Source code naming conventions:
================================================================================
Source code consists of C-callable CUDA routines and CUDA kernels. C-callable
functions can be found in the top level of the src/cuda directory and CUDA
kernels are found in the kernels directory.

cuda/
-------------------------------------------------------------------------------
oskar_cuda_as2hi        : antenna signal 2D horizontal isotropic
oskar_cuda_bf2hig       : beamformer 2D horizontal isotropic geometric
oskar_cuda_bfmv         : beamformer matrix vector
oskar_cuda_bp2hig       : beam pattern 2D horizontal isotropic geometric
oskar_cuda_bp2hcgg      : beam pattern 2D horizontal common gaussian geometric
oskar_cuda_bp2hugg      : beam pattern 2D horizontal unique gaussian geometric
oskar_cuda_im2dft       : imager 2D DFT


cuda/kernels/
-------------------------------------------------------------------------------
oskar_cudak_as2hi       : antenna signal 2D horizontal isotropic
oskar_cudak_bp2hiw      : beam pattern 2D horizontal isotropic weights
oskar_cudak_eq2hg       : equatorial to horizontal generic
oskar_cudak_im2dft      : imager 2D DFT
oskar_cudak_pc2ht       : pre-compute 2D horizontal trig
oskar_cudak_wt2hg       : weights 2D horizontal geometric



================================================================================
================================================================================
================================================================================

Testing and refactor.
---------------------


Aims:
--------------------------------------------------------------------------------
- Define a source code convension:
    - see: http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Namespaces
    - This seems pretty good.

- Improvements in clarity to find things:
    - Group code into subfolders for utility, imaging, simulation?
    - Remove redundant functions.
    - Rename variables in the interface to be more verbose.
        - names should be simple for a new reader of the code!

- Improve testing.
    - need both correctness and performance.
    - Test level one funtions i.e. weights generation etc.

- Sort out handling of cuda errors more strictly.
    - needed for error codes in matlab.
    - needed for deployment so unexpected errors do not occur.

- Improve deployment support for the library work out fully how a deplyed
version of the library can be used from matlab.
    - Components in the install targets for windows installer.
    - No real need to add oskar_cuda prefixes to source code as
        - 1. uniqueness of filename can be inforced by a folder path
        - ie
            oskar_cuda_foo.h
          can be just
            /oskar/cuda/foo.h
        - No real need for unique function names either
        - Its *very* *very* unlikely that someone will also have a function
        for example called e_jones_horizontal() in the *same* code base.


- Split into a clear level 1 and level 2 functions.
    - Level 1 functions (pretty much kernels) should be exposed by wrappers.
        - scale array etc.
    - Level 2 should reuse a lot more level 1.
    - Better support of switching from double to single precision.
    - what level 2 / level 3 is implemented in matlab rather than than in C/C++
       - move more level 2 / 3 to C/C++ classes/ functions when they are stable.





-----------------------------------------------------

- Beam pattern E jones calculation is a level 2 function.
    - Uses functions:
        - Weights generation
        - Some form of appodisation
        - ....
    - Therefore interface should be ...


==============================================
naming ideas for level 2:

Beampatterns.
    - does it ever make sense for the beampattern to be not in horizontal
      coordinates?
    - are there any other form of weights than geometric before modifiction?
        - ie by nulling or appodisation.
    - dont really need 2d/3d specifier as this should be obvious
      based on the fact that we are not specifying x,y *and* z!


- simulation/eJones_isotropic_antennas.h


    // this includes isotropic where the element pattern id sets this.

    = eJones_functional_element_pattern(
        const unsigned num_antennas,
        const float * antennas_x,
        const float * antennas_y,
        const float frequency,
        const float * azimuth,
        const float * elevation,
        const int * element_patterns,    // vector of enum values for each antenna (if length 1 all antennas are the same)
        const int apodisation_function,   // enum
        complex * eJones // return value
      );




    // Need a version for numerical patterns as these probably have to
    // be handled a bit differently.

    = eJones_numerical_element_pattern(
        const unsigned num_antennas,
        const float * antennas_x,
        const float * antennas_y,
        const float frequency,
        const float * azimuth,
        const float * elevation,
        ...
        const float * element_pattern,   // some form of element pattern.
        ....
        const int apodisation_function,   // enum
        complex * eJones // return value
      );



    // level 3 function?
    = beampattern_function_element_pattern(
        const unsigned num_antennas,
        const float * antennas_x,
        const float * antennas_y,
        const float frequency,
        const unsigned num_pixels,
        const float field_of_view,
        const int apoisation_function,
        const int * element_pattern,
        complex * beampattern
     );


- simulation/eJones_nulls.h














2d Beam pattern wrapper functions under review
==============================================
bp2hcggu  = horizontal, antenna pattern = common gaussian, geometric, un-normalised
bp2higau  = horizontal, isotropic, geometric weights, apodisation, un-normalised.
bp2higu   = horizontal, antenna pattern = sin, geometric weights, unnormalised.
bp2hsgu   = horizontal, antenna pattern = sin, geometric weights, unnormalised.
bp2hssgu  = horizontal, antenna pattern = sin^2, geometric weights, un-normalised.
bp2huggu  = horizontal, antenna pattern = unique gaussian per antenna, geometric weights, un-normalised.


Proposals
=========
1. Removed normalised version : (removes 10 functions)
Un-normalised versions can be very simply normalised outside the function either
on the host code or using a gpu call to some scaling function (probably blas).

2.


removed functions:

wrappers:
bp2hcgg   = horizontal, antenna pattern = common gaussian, geometric, normalised
bp2hig    = horizontal, antenna pattern = sin, geometric weights, normalised.
bp2hsg    = horizontal, antenna pattern = sin, geometric weights, normalised.
bp2hugg   = horizontal, antenna pattern = unique gaussian per antenna, geometric weights, normalised.
bp2hssg   = horizontal, antenna pattern = sin^2, geometric weights.

kernels:
oskar_cudak_wt2hg



TODO:
=====
check normalisation on hierarchical bp ...hbp2.... file. UNNORMALISED VERSIONS
