File: src/cuda/readme
===============================================================================

Description:
===============================================================================
This folder contains source code for the library module: oskar_cuda
This library provides math routines written in CUDA for execution on the GPU.

Library dependencies:
    cuda
    cudart
    cublas



Source code naming conventions:
================================================================================
Source code consists of C-callable CUDA routines and CUDA kernels. C-callable
functions can be found in the top level of the src/cuda directory and CUDA
kernels are found in the kernels directory.

cuda/
-------------------------------------------------------------------------------
oskar_cuda_as2hi        : antenna signal 2D horizontal isotropic
oskar_cuda_bf2hig       : beamformer 2D horizontal isotropic geometric
oskar_cuda_bp2hugg      : beam pattern 2D horizontal unique gaussian geometric


cuda/kernels/
-------------------------------------------------------------------------------
oskar_cudak_as2hi       : antenna signal 2D horizontal isotropic
oskar_cudak_bp2hiw      : beam pattern 2D horizontal isotropic weights
oskar_cudak_eq2hg       : equatorial to horizontal generic
oskar_cudak_im2dft      : imager 2D DFT
oskar_cudak_pc2ht       : pre-compute 2D horizontal trig
oskar_cudak_wt2hg       : weights 2D horizontal geometric



================================================================================
================================================================================
================================================================================

NOTES: Testing and refactoring
-------------------------------

Overall principle:
------------------
Variable and function names should be as exact as possible. If a comment is 
required to describe it, the function is either doing too much, or the name
can be clearer.
The goal is to have code that reads like a story. Changing variable and function
names and breaking them down into several functions if necessary to achieve
this goal. 

Questions:
----------
- If most of oskar-lib will be CUDA based is it a good idea to have a single
  CUDA module? rather than ones for imaging, beam-pattern, beam-forming, utility
  etc. ?!
- Should we try to expose a higher level interface to the library?
- At the moment it would seem that there is a degree of function creep between
  a level-1 and level-2 version of the library.

General goals:
--------------
- Improvements in clarity to find things:
    - Group code into sub-folders (e.g. utility, imaging, simulation)
    - Rename variables in the interface to be more verbose.
        - names should be simple for a new reader of the code!
    - No real need to add "oskar_cuda" prefixes to source code:
        - Adding the prefix adds extremely little to the ease of use of the
          library and readability of the code.          
        - Modularity and be expressed thought a folder structure.
        - Its *very* unlikely that users will have functions with the same names
          as OSKAR library function calls.
          i.e. why would anyone have a beam_pattern_horiztonal() function
          in their own code if they are calling the OSKAR version.
          Can add namespace control in the C++ interface. i.e.
            #ifdef __cplusplus
              namespace oskar-lib {
              extern "C" {
            #endif
          And from Matlab this is a non issue as functions are called
          indirectly via calllib() anyway.
            
- Improve testing.
    - Need both correctness and performance.
    - Simple tests of level-one functions.

- Sort out handling of CUDA errors more strictly.
    - Error codes returned to Matlab.
    - Define some standards!

- Improve deployment support.
    - Windows version DllExport macros.
    - Work out how best to include headers in an installed environment.
   
==============================================================================


Todo:
------

0. Top level library design.

1. Brainstorm more logical groupings for the simulator.

2. Come up with a descriptive narrative for what each function should do with 
   the goal to come up with some better naming schemes and how to split up
   functions.
   e.g.   
   == e-jones evaluation function (better to call beam pattern?)
   == single level function. (rather than hierarchical)
   == generates the beam pattern in horizontal coordinates (is there any other?!)
      == This function
         - Takes ...
         - Generates geometric weights
         - Applies some form of apodisation.
         - ...
      == If this is getting too complicated split into several stages.
      == And write a wrapper for the simple stages if it is helpful.
      ->> this will lead to an interface which can be easily described as...
