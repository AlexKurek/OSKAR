%
% This is an autogenerated file - do not edit!
%


\fontsize{8}{10}\selectfont
\begin{center}
\begin{longtable}{|L{9cm}|L{8.5cm}|L{4.0cm}|L{1.7cm}|}

\hline
  \rowcolor{lightgray}
  {\textbf{Key}} &
  {\textbf{Description}} &
  {\textbf{Allowed values}} &
  {\textbf{Default}} \\ \hline
\endfirsthead
\hline
  \rowcolor{lightgray}
  {\textbf{Key}} &
  {\textbf{Description}} &
  {\textbf{Allowed values}} &
  {\textbf{Default}} \\ \hline
\endhead
  \multicolumn{4}{l}{{Continued on next page\ldots}} \\
\endfoot
 
\endlastfoot
double\_precision
&
{Determines whether double precision arithmetic is used.}
&
Bool
&
true
\\
\hline

cuda\_device\_ids
&
{A comma-separated string containing device (GPU) IDs to use on a multi-GPU system, or `all' to use all devices.}
&
CSV integer list or `all'
&
all
\\
\hline

specify\_cellsize
&
{If set, specify cellsize; otherwise, specify field of view.}
&
Bool
&
false
\\
\hline

fov\_deg
&
{Total field of view in degrees.}
&
Unsigned double
&
2.0
\\
\hline

cellsize\_arcsec
&
{The cell (pixel) size in arcseconds.}
&
Unsigned double
&
1.0
\\
\hline

size
&
{Image width in one dimension (e.g. a value of 256 would give a 256 by 256 image). This must be even.}
&
Integer > 0
&
256
\\
\hline

image\_type
&
{The type of image to generate. Note that the Stokes parameter images (if selected) are uncalibrated, and are formed simply using the standard combinations of the linear polarisations: 
{\begin{itemize}[leftmargin=5ex, topsep=0pt, partopsep=0pt, itemsep=4pt, parsep=0pt]
\vspace{8pt}
 \item {I = 0.5 (XX + YY)}
 \item {Q = 0.5 (XX - YY)}
 \item {U = 0.5 (XY + YX)}
 \item {V = -0.5i (XY - YX)}
 \vspace{8pt}
\end{itemize}}
 The point spread function of the observation can be generated using the PSF option.}
&
{One of the following:}
{\begin{itemize}[leftmargin=5ex, topsep=0pt, partopsep=0pt, itemsep=2pt, parsep=0pt]
\vspace{4pt}\item {Linear (XX,XY,YX,YY)}
\item {XX}
\item {XY}
\item {YX}
\item {YY}
\item {Stokes (I,Q,U,V)}
\item {I}
\item {Q}
\item {U}
\item {V}
\item {PSF}
\end{itemize}
}
&
I
\\
\hline

channel\_snapshots
&
{If true, then produce an image cube containing snapshots for each frequency channel. If false, then use frequency-synthesis to stack the channels in the final image.}
&
Bool
&
true
\\
\hline

channel\_start
&
{The start channel index to include in the image or image cube.}
&
Unsigned integer
&
0
\\
\hline

channel\_end
&
{The end channel index to include in the image or image cube.}
&
{Integer $\geq$ 0, or `max'}
&
max
\\
\hline

time\_snapshots
&
{If true, then produce an image cube containing snapshots for each time step. If false, then use time-synthesis to stack the times in the final image.}
&
Bool
&
false
\\
\hline

time\_start
&
{The start time index to include in the image or image cube.}
&
Unsigned integer
&
0
\\
\hline

time\_end
&
{The end time index to include in the image or image cube.}
&
{Integer $\geq$ 0, or `max'}
&
max
\\
\hline

uv\_filter\_min
&
{The minimum UV baseline length to image, in wavelengths.}
&
Unsigned double
&
0.0
\\
\hline

uv\_filter\_max
&
{The maximum UV baseline length to image, in wavelengths.}
&
{Double $\geq$ 0, or `max'}
&
max
\\
\hline

algorithm
&
{The type of transform used to generate the image.}
&
{One of the following:}
{\begin{itemize}[leftmargin=5ex, topsep=0pt, partopsep=0pt, itemsep=2pt, parsep=0pt]
\vspace{4pt}\item {FFT}
\item {DFT 2D}
\item {DFT 3D}
\item {W-projection}
\end{itemize}
}
&
FFT
\\
\hline

weighting
&
{The type of visibility weighting scheme to use.}
&
{One of the following:}
{\begin{itemize}[leftmargin=5ex, topsep=0pt, partopsep=0pt, itemsep=2pt, parsep=0pt]
\vspace{4pt}\item {Natural}
\item {Radial}
\item {Uniform}
\end{itemize}
}
&
Natural
\\
\hline

fft/use\_gpu
&
{If true, use the GPU to perform the FFT.}
&
Bool
&
false
\\
\hline

fft/kernel\_type
&
{The type of gridding kernel to use.}
&
{One of the following:}
{\begin{itemize}[leftmargin=5ex, topsep=0pt, partopsep=0pt, itemsep=2pt, parsep=0pt]
\vspace{4pt}\item {Spheroidal}
\item {Pillbox}
\end{itemize}
}
&
Spheroidal
\\
\hline

fft/support
&
{The support size used for the gridding kernel.}
&
Int
&
3
\\
\hline

fft/oversample
&
{The oversample factor used for the gridding kernel.}
&
Int
&
100
\\
\hline

wproj/generate\_w\_kernels\_on\_gpu
&
{If true, use the GPU to generate the W-kernels.}
&
Bool
&
true
\\
\hline

wproj/num\_w\_planes
&
{The number of W-planes to use. Values less than 1 mean "auto".}
&
Int
&
0
\\
\hline

direction
&
{Specifies the direction of the image phase centre. 
{\begin{itemize}[leftmargin=5ex, topsep=0pt, partopsep=0pt, itemsep=4pt, parsep=0pt]
\vspace{8pt}
 \item {If \textbf{Observation direction} is selected, the image is centred on the pointing direction of the primary beam.}
 \item {If \textbf{RA, Dec.} is selected, the image is centred on the values of RA and Dec. found below.}
 \vspace{8pt}
\end{itemize}}
}
&
{One of the following:}
{\begin{itemize}[leftmargin=5ex, topsep=0pt, partopsep=0pt, itemsep=2pt, parsep=0pt]
\vspace{4pt}\item {Observation direction}
\item {RA, Dec.}
\end{itemize}
}
&
Observation
\\
\hline

direction/ra\_deg
&
{The Right Ascension of the image phase centre. This value is used if the image centre direction is set to `RA, Dec.'.}
&
Double
&
0.0
\\
\hline

direction/dec\_deg
&
{The Declination of the image phase centre. This value is used if the image centre direction is set to `RA, Dec.'.}
&
Double
&
0.0
\\
\hline

input\_vis\_data
&
{Path to the input OSKAR visibility data file or Measurement Set.}
&
Path name
&
None
\\
\hline

ms\_column
&
{The name of the column in the Measurement Set to use, if applicable.}
&
{One of the following:}
{\begin{itemize}[leftmargin=5ex, topsep=0pt, partopsep=0pt, itemsep=2pt, parsep=0pt]
\vspace{4pt}\item {DATA}
\item {MODEL\_DATA}
\item {CORRECTED\_DATA}
\end{itemize}
}
&
DATA
\\
\hline

root\_path
&
{The root filename used to save the output image. The full filename will be constructed as {\texttt{\textbf{$<$root$>$\_$<$image\_type$>$.fits }}}}
&
Path name
&
None
\\
\hline

\end{longtable}
\end{center}
\normalsize
\newpage
